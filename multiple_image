import os
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, Any, List
import cv2
import numpy as np
import pandas as pd
from tqdm import tqdm


@dataclass(frozen=True)
class AlgoParams:


    gaussian_ksize: Tuple[int, int] = (5, 5)

    # Canny edge detection
    canny_th1: int = 30
    canny_th2: int = 100

    morph_ksize: Tuple[int, int] = (5, 5)
    dilate_iter: int = 2
    erode_iter: int = 1

    # Legendre fitting
    legendre_deg: int = 5
    n_fit: int = 500

    min_contour_points: int = 5


    roi: Optional[Tuple[int, int, int, int]] = None


    area_range: Optional[Tuple[float, float]] = None  # (min_area_px2, max_area_px2)
    min_circularity: Optional[float] = None  # 4*pi*A/P^2


    pixel_to_mm: Optional[float] = None  # mm / pixel
    mass_g: Optional[float] = None  # sample mass in grams


def _apply_roi_mask(binary_img: np.ndarray, roi: Optional[Tuple[int, int, int, int]]) -> np.ndarray:
    if roi is None:
        return binary_img
    x, y, w, h = roi
    x = max(0, x)
    y = max(0, y)
    w = max(1, w)
    h = max(1, h)
    mask = np.zeros_like(binary_img)
    cv2.rectangle(mask, (x, y), (x + w, y + h), 255, -1)
    return cv2.bitwise_and(binary_img, mask)


def _preprocess_image(gray: np.ndarray, params: AlgoParams) -> np.ndarray:
    #Invert + Gaussian blur (paper Fig.1(b)).
    inverted = cv2.bitwise_not(gray)
    blurred = cv2.GaussianBlur(inverted, params.gaussian_ksize, 0)
    return blurred


def _extract_edges(preprocessed: np.ndarray, params: AlgoParams) -> np.ndarray:
    #Canny + morphology closing (paper Fig.1(c–d))
    edges = cv2.Canny(preprocessed, params.canny_th1, params.canny_th2)
    kernel = np.ones(params.morph_ksize, np.uint8)
    edges = cv2.dilate(edges, kernel, iterations=params.dilate_iter)
    edges = cv2.erode(edges, kernel, iterations=params.erode_iter)
    return edges


def _contour_circularity(contour: np.ndarray) -> float:
    area = cv2.contourArea(contour)
    peri = cv2.arcLength(contour, True)
    if peri <= 0:
        return 0.0
    return float(4.0 * np.pi * area / (peri * peri))


def _select_droplet_contour(edges: np.ndarray, params: AlgoParams) -> Optional[np.ndarray]:

    edges_use = _apply_roi_mask(edges, params.roi)

    contours, _ = cv2.findContours(edges_use, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return None

    candidates: List[np.ndarray] = []
    for c in contours:
        if len(c) < params.min_contour_points:
            continue

        area = cv2.contourArea(c)
        if params.area_range is not None:
            a_min, a_max = params.area_range
            if area < a_min or area > a_max:
                continue

        if params.min_circularity is not None:
            if _contour_circularity(c) < params.min_circularity:
                continue

        candidates.append(c)

    if not candidates:
        return None

    return max(candidates, key=cv2.contourArea)


def _ellipse_metrics(contour: np.ndarray) -> Dict[str, float]:
    #Ellipse fitting
    ellipse = cv2.fitEllipse(contour)
    (cx, cy), (major_axis_length, minor_axis_length), angle = ellipse

    # Effective radius from mean diameter
    r_px = (major_axis_length + minor_axis_length) / 4.0
    v_px3 = (4.0 / 3.0) * np.pi * (r_px ** 3)

    return {
        "cx": float(cx),
        "cy": float(cy),
        "major_px": float(major_axis_length),
        "minor_px": float(minor_axis_length),
        "angle_deg": float(angle),
        "r_px": float(r_px),
        "v_px3": float(v_px3),
    }


def _legendre_metrics(contour: np.ndarray, params: AlgoParams) -> Dict[str, Any]:

    pts = contour.squeeze()
    x = pts[:, 0].astype(float)
    y = pts[:, 1].astype(float)


    model_yx = np.polynomial.legendre.Legendre.fit(x, y, deg=params.legendre_deg)
    model_xy = np.polynomial.legendre.Legendre.fit(y, x, deg=params.legendre_deg)

    x_fit = np.linspace(x.min(), x.max(), params.n_fit)
    y_fit = model_yx(x_fit)

    y_fit_inv = np.linspace(y.min(), y.max(), params.n_fit)
    x_fit_inv = model_xy(y_fit_inv)

    # Diameter endpoints (paper: evaluate at extrema in each orientation)
    idx_left = int(np.argmin(x_fit))
    idx_right = int(np.argmax(x_fit))
    pt_left = (int(x_fit[idx_left]), int(y_fit[idx_left]))
    pt_right = (int(x_fit[idx_right]), int(y_fit[idx_right]))

    idx_top = int(np.argmin(y_fit_inv))
    idx_bottom = int(np.argmax(y_fit_inv))
    pt_top = (int(x_fit_inv[idx_top]), int(y_fit_inv[idx_top]))
    pt_bottom = (int(x_fit_inv[idx_bottom]), int(y_fit_inv[idx_bottom]))

    horiz_px = float(np.hypot(pt_right[0] - pt_left[0], pt_right[1] - pt_left[1]))
    vert_px = float(np.hypot(pt_bottom[0] - pt_top[0], pt_bottom[1] - pt_top[1]))

    d_avg_px = (horiz_px + vert_px) / 2.0
    r_px = d_avg_px / 2.0
    v_px3 = (4.0 / 3.0) * np.pi * (r_px ** 3)


    curve1 = np.array([x_fit, y_fit]).T.astype(int)
    curve2 = np.array([x_fit_inv, y_fit_inv]).T.astype(int)

    return {
        "horiz_px": horiz_px,
        "vert_px": vert_px,
        "d_avg_px": float(d_avg_px),
        "r_px": float(r_px),
        "v_px3": float(v_px3),
        "pt_left": pt_left,
        "pt_right": pt_right,
        "pt_top": pt_top,
        "pt_bottom": pt_bottom,
        "curve1": curve1,
        "curve2": curve2,
    }


def _physical_from_radius(r_px: float, params: AlgoParams) -> Dict[str, Optional[float]]:
    if params.pixel_to_mm is None:
        return {"r_mm": None, "v_mm3": None, "v_cm3": None, "rho_g_cm3": None}

    r_mm = float(r_px * params.pixel_to_mm)
    v_mm3 = float((4.0 / 3.0) * np.pi * (r_mm ** 3))
    v_cm3 = float(v_mm3 / 1000.0)  # 1 cm^3 = 1000 mm^3

    rho = None
    if params.mass_g is not None and v_cm3 > 0:
        rho = float(params.mass_g / v_cm3)

    return {"r_mm": r_mm, "v_mm3": v_mm3, "v_cm3": v_cm3, "rho_g_cm3": rho}


def process_image(image_path: str, save_path: str, params: Optional[AlgoParams] = None) -> Optional[Dict[str, Any]]:

    if params is None:
        params = AlgoParams()

    gray = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if gray is None:
        print(f"无法读取图片：{image_path}")
        return None

    pre = _preprocess_image(gray, params)
    edges = _extract_edges(pre, params)

    contour = _select_droplet_contour(edges, params)
    if contour is None:
        print(f"未找到合格轮廓：{image_path}")
        return None
    if len(contour) < params.min_contour_points:
        print(f"轮廓点不足，无法拟合：{image_path}")
        return None

    out = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)

    # --- Ellipse fitting (blue) ---
    em = _ellipse_metrics(contour)
    ellipse = ((em["cx"], em["cy"]), (em["major_px"], em["minor_px"]), em["angle_deg"])
    cv2.ellipse(out, ellipse, (255, 0, 0), 2)

    # --- Legendre fitting
    lm = _legendre_metrics(contour, params)


    for i in range(len(lm["curve1"]) - 1):
        cv2.line(out, tuple(lm["curve1"][i]), tuple(lm["curve1"][i + 1]), (255, 255, 0), 2)
    for i in range(len(lm["curve2"]) - 1):
        cv2.line(out, tuple(lm["curve2"][i]), tuple(lm["curve2"][i + 1]), (255, 255, 0), 2)


    for p in [lm["pt_left"], lm["pt_right"], lm["pt_top"], lm["pt_bottom"]]:
        cv2.circle(out, p, 5, (0, 0, 255), -1)


    cv2.line(out, lm["pt_left"], lm["pt_right"], (0, 165, 255), 2)
    cv2.line(out, lm["pt_top"], lm["pt_bottom"], (0, 165, 255), 2)


    ep = _physical_from_radius(em["r_px"], params)
    lp = _physical_from_radius(lm["r_px"], params)

    # Text annotation (upper-left, color-coded)
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 0.7
    thickness = 2

    text_lines = [
        (f"Ellipse Major: {em['major_px']:.2f}px", (10, 30), (255, 0, 0)),
        (f"Ellipse Minor: {em['minor_px']:.2f}px", (10, 60), (255, 0, 0)),
        (f"Ellipse Volume: {em['v_px3']:.2f} px^3", (10, 90), (255, 0, 0)),
        (f"Legendre Horiz: {lm['horiz_px']:.2f}px", (10, 130), (0, 165, 255)),
        (f"Legendre Vert: {lm['vert_px']:.2f}px", (10, 160), (0, 165, 255)),
        (f"Legendre Volume: {lm['v_px3']:.2f} px^3", (10, 190), (0, 165, 255)),
    ]


    if ep["rho_g_cm3"] is not None:
        text_lines.append((f"Ellipse Density: {ep['rho_g_cm3']:.3f} g/cm^3", (10, 230), (255, 0, 0)))
    if lp["rho_g_cm3"] is not None:
        text_lines.append((f"Legendre Density: {lp['rho_g_cm3']:.3f} g/cm^3", (10, 260), (0, 165, 255)))

    for text, pos, color in text_lines:
        cv2.putText(out, text, pos, font, font_scale, color, thickness)

    cv2.imwrite(save_path, out)

    return {
        # Ellipse 
        "椭圆长轴_px": em["major_px"],
        "椭圆短轴_px": em["minor_px"],
        "椭圆角度_deg": em["angle_deg"],
        "椭圆半径_px": em["r_px"],
        "椭圆体积_px3": em["v_px3"],

        # Legendre
        "勒让德水平直径_px": lm["horiz_px"],
        "勒让德垂直直径_px": lm["vert_px"],
        "勒让德平均直径_px": lm["d_avg_px"],
        "勒让德半径_px": lm["r_px"],
        "勒让德体积_px3": lm["v_px3"],

        # Optional physical units
        "椭圆半径_mm": ep["r_mm"],
        "椭圆体积_mm3": ep["v_mm3"],
        "椭圆体积_cm3": ep["v_cm3"],
        "椭圆密度_g_cm3": ep["rho_g_cm3"],

        "勒让德半径_mm": lp["r_mm"],
        "勒让德体积_mm3": lp["v_mm3"],
        "勒让德体积_cm3": lp["v_cm3"],
        "勒让德密度_g_cm3": lp["rho_g_cm3"],
    }


def extract_number_from_filename(filename):
    try:
        start = filename.index('_') + 1
        timestamp = filename[start:start + 17]
        return timestamp if timestamp.isdigit() else None
    except ValueError:
        return None


def parse_timestamp(timestamp):
    if not timestamp or len(timestamp) != 17:
        return [None] * 7
    return [int(timestamp[:4]), int(timestamp[4:6]), int(timestamp[6:8]),
            int(timestamp[8:10]), int(timestamp[10:12]), int(timestamp[12:14]), int(timestamp[14:17])]


def process_images_in_folder(input_folder, output_folder, excel_path, params: Optional[AlgoParams] = None):
    os.makedirs(output_folder, exist_ok=True)
    if params is None:
        params = AlgoParams()
    data = []

    for filename in tqdm(os.listdir(input_folder)):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.tiff')):
            input_path = os.path.join(input_folder, filename)
            output_path = os.path.join(output_folder, filename)

            timestamp = extract_number_from_filename(filename)
            year, month, day, hour, minute, second, millisecond = parse_timestamp(timestamp)

            result = process_image(input_path, output_path, params=params)
            if result:
                data.append([
                    filename, timestamp,
                    result['椭圆长轴_px'], result['椭圆短轴_px'], result['椭圆角度_deg'], result['椭圆体积_px3'],
                    result['勒让德水平直径_px'], result['勒让德垂直直径_px'], result['勒让德体积_px3'],
                    result['椭圆密度_g_cm3'], result['勒让德密度_g_cm3'],
                    year, month, day, hour, minute, second, millisecond
                ])

    df = pd.DataFrame(data, columns=[
        '图片名称', '时间戳',
        '椭圆长轴_px', '椭圆短轴_px', '椭圆角度_deg', '椭圆体积_px3',
        '勒让德水平直径_px', '勒让德垂直直径_px', '勒让德体积_px3',
        '椭圆密度_g_cm3', '勒让德密度_g_cm3',
        '年', '月', '日', '时', '分', '秒', '毫秒'
    ])
    df.to_excel(excel_path, index=False)
    print(f"处理完成！结果已保存到 {excel_path}")



if __name__ == "__main__":
    input_folder = '/Users/ye/Desktop/aa'  # 输入文件夹路径
    output_folder = '/Users/ye/Desktop/aa2'  # 输出文件夹路径
    excel_path = os.path.join(output_folder, '图片处理结果.xlsx')


    params = AlgoParams(

        roi=None, 
        area_range=None,  
        min_circularity=None,


        pixel_to_mm=None,  
        mass_g=None, 
    )

    process_images_in_folder(input_folder, output_folder, excel_path, params=params)
